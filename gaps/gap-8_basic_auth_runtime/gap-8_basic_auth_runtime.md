---
gap: 8
title: Basic auth runtime
description: A generic runtime for services secured by HTTP basic authentication.
author: mf (@mfranciszkiewicz)
status: Draft
type: Feature
---

## Abstract

A generic runtime for services secured by HTTP basic authentication, provided on the Golem Network. The services
in subject are exposed to the Internet via host's (provider's) operating system.

The runtime binary is accompanied by a custom reverse-proxy HTTP server, responsible for forwarding requests from 
the end-users to services and gathering API call statistics per service user.

## Motivation

The original runtime specification has been derived from the results of work on the Erigon and Lighthouse service 
runtimes. It was concluded that this kind of runtime could be useful for any REST service, which does not enforce 
its own security mechanism.

## Specification

The following is an overhauled version of the [original specification](https://www.notion.so/golemnetwork/Basic-auth-runtime-specification-59b6d111e4de4426ac230e729222c91a):

- Provider should be able to add/remove services by adding/removing config files from some designated directory
- The runtime should control access to services by HTTP basic auth.
    - There should be a separate access list for every service.
    - Requestor should be able to pass in the access credentials (username + password) â€“ these should **not** be generated by the runtime. User name collision should be handled.
    - Each activity is limited to a single pair of access credentials.
- Runtime should expose number of requests as a custom usage metric.
    - Breakdown of request count into particular service endpoints (i.e. URL paths) is nice-to-have.
  
This GAP abandons the idea of managing HTTP basic auth credentials of a third-party web server via `.htpasswd` files. 
Instead, a custom implementation of a reverse HTTP proxy is proposed, responsible for:

- authenticating users
- forwarding authenticated HTTP requests to services
- exposing a management API for:
  - adding / removing a service (paginated, parameterized ordering)
  - listing registered services
  - adding / removing access credentials per service
  - listing registered users (paginated, parameterized ordering)
  - reading usage statistics per service user
  - reading total usage statistics (optional)
- securing HTTP communication with TLS

### Runtime implementation

Base the implementation on [ya-runtime-sdk](https://github.com/golemfactory/ya-runtime-sdk)
- use [ya-runtime-basic-auth](https://github.com/golemfactory/yagna-service-erigon/tree/master/ya-runtime-basic-auth) as a starting point
- refer to [this comment](https://github.com/golemfactory/yagna-service-erigon/pull/47#issuecomment-983924928) for general guidance

#### Command line arguments

Command line arguments should accept a runtime name parameter.

An example can be found [here](https://github.com/golemfactory/ya-runtime-sdk/blob/mf/dynamic-rt-name/examples/environment/src/main.rs).

#### Configuration

The configuration file may contain the following (optional) values:
- proxy Management API address(es)
- proxy log path
- additional service config lookup directories

#### Background jobs

Implement the following in order to publish the custom runtime counter values: 

1. Runtime counter fetcher

   Periodically calls the stats endpoint of proxy's Management API for the current user.

2. Supervisor counter publisher
   
   Periodically updates the custom counter value (total requests made by a user).
   An example of a custom counter can be found [here](https://github.com/golemfactory/ya-test-runtime-counters/blob/main/src/main.rs).


#### `Runtime` trait implementation

1. `deploy`

- if not running, **in background**, start an instance of the proxy server; the proxy binary is expected to reside in the
  same directory as the runtime binary.The proxy binary is guarded via a lock file when starting up.
  - loop
    - if no lock file is present, create and lock the file
      - start the process and use the via Management API to check whether it's responding properly
      - break
    - if the file is present, wait for acquiring the lock
      - if the Management API is responding, break 
      - else, create the process and await until it's responsive

- if not running, **in background**, start an instance of the current service binary 
  and wait until the application is ready to accept commands. Use the same file-lock mechanism as in case of
  spawning the proxy process.

- service startup is managed via the filesystem - i.e. lock or pid files; TBD by the runtime developer

2. `start`

- none

3. `run`

    - `credentials <username> <password>`

      Sets the credentials that will be used in the current activity. If a username exists,
      returns an error (with a proper message outputted to `stderr`); the runtime is terminated.

    - `counter <name> <username> <password>` (optional)

      Reads the specific counter value for a given user. The foreseen counter
      names will be set to the requested URIs (locations) configured in nginx.

4. `transfer`

    - none

5. `offer-template`

- include a `https` runtime capability in an offer, if the server supports HTTPS
- (optional) extra Offer properties defined in service configuration
- (optional) partial service configuration as Offer properties (e.g. cpu threads, timeout values, user auth method)
- (optional) in case of self-signed certificates, add a `cert` string property in the runtime property namespace,
  containing the certificate

6. `test`

- discover and start services
- perform a proxy test
  - start the proxy
  - resolve and register all services
  - perform a health-check for each service
- terminate services 

- executes the managed service binary and tries to parse the standard output of a sample command, e.g.`<binary> --version`
- performs (idempotent) requests to the test API URIs of supported services via HTTPS; starts services when needed
- (optional) performs a public IP check

#### Shutdown procedure

Implement a process termination handler using `ya-runtime-sdk`:

1. Fetch last available counter values via Management API
2. Publish the latest known counter values via `ya-runtime-sdk`
3. Deregister the user (if any) via Management API

### Deployment

Each service should be assigned its own runtime name and use the common `ya-runtime-basic-auth` binary, e.g.:

```json
[
  {
    "name": "ya-runtime-erigon",
    "version": "0.1.0",
    "supervisor-path": "exe-unit",
    "runtime-path": "ya-runtime-basic-auth/ya-runtime-basic-auth",
    "description": "The Basic-Auth runtime for the Erigon service",
    "extra-args": [
      "--runtime-managed-image",
      "--runtime-arg", "ya-runtime-erigon"
    ]
  }
]
```

depending on the installation method, located at:
- `/usr/lib/yagna/plugins/ya-runtime-erigon.json` (manual or `deb` installation)
- `~/.local/lib/yagna/plugins/ya-runtime-erigon.json` (installer script)

### Basic auth proxy

Multi-threaded TCP server supporting HTTP 1.1 and HTTP 2.0 protocols, implemented in Rust using `hyper` / `actix-web`
(to be decided by the proxy developer(s)).

The proxy binds to (at least) 2 address spaces, unless configured otherwise:
- private (`localhost:9013`) for the Management API
- public (`0.0.0.0:[80|443]`) for the public reverse proxy

#### Management API (private address space)

Management API implementation keeps track of the number of registered users and de-registers services when the user counter reaches 0 
(i.e. at least one user needs to be registered first).

1. Service management

- `GET /services -> List[Service]` ? [`pageSize`, `offset`, `count`]
    
  Retrieves a list of registered services

- `POST /services` w/ `CreateService`
    
  Registers a service; returns 204 if the service already exists and all service parameters match.
    
  Tries to spawn an additional HTTP server thread when any of these conditions are met:
  - the listening address is not covered by the default configuration
  - service port is not covered by the default configuration

  In other cases, the default server thread will be used, but the service configuration must match the default
  proxy configuration (listening address, certificates, etc.).

- `GET /services/{service_name} -> Service`
    
  Retrieves service details
  
- `DELETE /services/{service_name}`

  De-registers a service and stops the extra HTTP server (if any)

2. User management per service

- `GET /services/{service_name}/users -> List[UserStub]` ? [`pageSize`, `offset`, `count`]

  Lists users registered within the service

- `POST /services/{service_name}/users` w/ `CreateUser`

  Registers a new user within the service; returns 400 if a username already exists

- `GET /services/{service_name}/users/{user_name} -> User`

  Retrieves single registered user information

- `DELETE /services/{service_name}/users/{user_name}`

  De-registers a user from the service. If the user count drops to 0, de-registers the service and stops the
  extra HTTP server (if any)

3. User statistics

- `GET /services/{service_name}/users/{user_name}/stats -> UserStats`

  Per-service user statistics

- `GET /services/{service_name}/users/{user_name}/endpoints/stats -> UserEndpointStats`

  Per-endpoint, per-service user statistics

4. Global statistics (optional)

- `GET /stats -> GlobalStats`

Runtime developers are expected to create an OpenAPI specification of the Management API.

#### Proxy (public address space)

The public TCP connection handler inspects and mangles each incoming HTTP request only to forward that request
to the destination service server and tunnel the response.

The inspection and mangling module operates as follows:

1. Resolve the registered service basing on the requested URI
2. Authorize credentials included in the header
3. Rewrite the location in request's header to a relative service URI (the extra part of the proxied service endpoint)
4. Add / replace a `X-Forwarded-Host` header, if a domain name was set for the service
5. Add / replace a `X-Forwarded-For` header containing the connecting client's IP address
6. (optional, TBD) Add / replace a `Forward` header instead `X-Forwarded-For`
7. Forward the requested packet to the destination service server

The proxy server should update statistics for each unauthorized (global), failed (user / global) and successful request (user / global).

#### API models

- `CreateService`

  ```json
  {
    "name": "service_name",
    "command": "/usr/bin/service --xms",
    "bind": [
      "1.120.111.43:443"
    ],
    "user": {
      "auth": {
        "method": "basic"
      },
      "requestTimeout": 10000,
      "responseTimeout": 2000
    },
    "auth": {
      "method": "basic"
    },
    "cert": {
      "path": "/etc/certs/cert.crt",
      "keyPath": "/etc/certs/cert.key"
    },
    "from": "/service",
    "to": "http://127.0.0.1:12345/api/v1/service",      
    "requestTimeout": 10000,
    "responseTimeout": 2000,
    "cpuThreads": 2
  }
  ```

- `Service`

  `CreateService` extended with a `createdAt` property (RFC3339 timestamp as string).

- `CreateUser`

  ```json
  {
    "name": "username",
    "password": "dXNlcm5hbWU="
  }
  ```

  - `password` - base64 encoded password

- `User`

  ```json
  {
    "name": "username",
    "createdAt": "2022-01-12T23:20:50.52Z"
  }
  ```

- `UserStats`

  ```json
  {
    "total": 12,
    "failures": 0
  }
  ```

- `UserEndpointStats`

  ```json
  {
    "/service/run": 1,
    "/service/build": 12
  }
  ```

- `UserEndpointStats`

  ```json
  {
    "/service/run": 1,
    "/service/build": 12
  }
  ```

- `GlobalStats` (optional)

  ```json
  {
    "users": 43,
    "services": 3,
    "requests": {
      "total": 11314,
      "unauthorized": 44,
      "failures": 1
    }
  }
  ```
  
#### CLI

The proxy server can be parameterized via the following command line arguments: 

- (optional) proxy Management API addresses
- (optional) proxy log path
- (optional) proxy API binding address (defaults to `0.0.0.0:80` and `0.0.0.0:443` for both IPv4 and IPv6, if available)
- (optional) TLS certificate path
- (optional, required if TLS certificate path is set) TLS certificate key path

### Service configuration

Configuration files should contain the following service information in a JSON / YAML / TOML format:

- name (identifier)
- command for executing the binary
- domain name (e.g. `golem.network`)
- root local REST endpoint
- root service URL
- (optional) user request timeout
- (optional) user response timeout
- (optional) service request timeout
- (optional) service response timeout
- (optional) server binding addresses
- (optional) dedicated certificate entry (e.g. when binding to a separate network interface, resolvable under a different domain name)
  - certificate path
  - certificate key path
- (optional) number of designated CPU threads (defaults to all available logical cores)
- (optional) extra static properties to be included in the Offer
- (unused) user authentication method (basic auth only)
- (unused) service authentication method (basic auth only)

## Rationale

### Custom reverse HTTP proxy

TBD

### Self-signed certificates

HTTP authentication credentials are sent with each API call and need to be encrypted. A decision was made to 
support self-signed certificates to increase potential provider adoption. 

In future runtime iterations, both plain-text HTTP communication and the use of self-signed certificates should be 
discouraged or disallowed; i.e. the `test` command may fail if the certificate is self-signed or the runtime is
able to perform plain HTTP API calls.

## Backwards Compatibility

N/A

## Test Cases

TBD

## Security Considerations

- the provider needs to properly configure TLS certificates so that the authentication credentials 
  cannot be sniffed (i.e. they won't be sent as plain text)
- (optional) self-signed certificates need to be included in the offer in order to prevent Man In The Middle attacks

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
